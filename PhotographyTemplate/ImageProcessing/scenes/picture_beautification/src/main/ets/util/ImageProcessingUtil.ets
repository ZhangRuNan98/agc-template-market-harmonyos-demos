import { image } from '@kit.ImageKit'
import { FilterModel } from '../model/BeautificationParam';
import { effectKit } from '@kit.ArkGraphics2D';

export class ImageProcessingUtil {
  //图片加滤镜
  static filterImage(item: FilterModel, pixelMap:PixelMap):Promise<PixelMap> {
    let filter = effectKit.createEffect(pixelMap);
    filter.blur(item.filterOptions.blur)
    if (item.filterOptions.grayscale) {
      filter.grayscale()
    }
    if (item.filterOptions.invert) {
      filter.invert()
    }
    filter.setColorMatrix(item.filterOptions.colorMatrix)
    filter.brightness(item.filterOptions.brightness)
    if (item.filterOptions.grayscale) {
      filter.grayscale()
    }
    return filter.getEffectPixelMap()
  }

  //矩形裁剪
  static getRectanglePixelMap(pixelMap: PixelMap, x: number, y: number, width: number, height: number) {
    let imageInfo = pixelMap.getImageInfoSync()
    let widthOrg = imageInfo.size.width
    let heightOrg = imageInfo.size.height
    let readBuffer: ArrayBuffer = new ArrayBuffer(widthOrg * heightOrg * 4)
    let desBuffer: ArrayBuffer = new ArrayBuffer(width * height * 4)
    pixelMap.readPixelsToBufferSync(readBuffer)
    let uint32Buffer: Uint32Array = new Uint32Array(readBuffer)
    let uint8BufferTemp: Uint8Array = new Uint8Array(desBuffer)
    if (x >= widthOrg) {
      x = widthOrg - 1
    }

    if (y >= heightOrg) {
      y = heightOrg - 1
    }
    if (width > (widthOrg - x)) {
      width = widthOrg - x
    }

    if (height > (heightOrg - y)) {
      height = heightOrg - y
    }

    for (let h = 0; h < height; h++) {
      for (let w = 0; w < width; w++) {
        let index = (y + h) * widthOrg + (x + w)
        let pixelColor = uint32Buffer[index]
        let indexTemp = h * width + w
        uint8BufferTemp[indexTemp*4] = (pixelColor >> 16) & 0x000000ff
        uint8BufferTemp[indexTemp * 4+1] = (pixelColor >> 8) & 0x000000ff
        uint8BufferTemp[indexTemp * 4+2] = (pixelColor >> 0) & 0x000000ff
        uint8BufferTemp[indexTemp * 4+3] = (pixelColor >> 24) & 0x000000ff
      }
    }

    let color: ArrayBuffer = uint8BufferTemp.buffer as ArrayBuffer;
    let opts: image.InitializationOptions =
      { editable: true, pixelFormat: imageInfo.pixelFormat, size: { height: height, width: width } }
    let pixelMapTemp: image.PixelMap = image.createPixelMapSync(color, opts);
    return pixelMapTemp;
  }
}
